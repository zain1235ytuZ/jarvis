# import speech_recognition as sr
# import webbrowser
# import pyttsx3
# import time
# import socket
# import sys
# import music
# import requests
# from client_improved import OpenAIClient

# openai_client = OpenAIClient()
# engine = pyttsx3.init()

# NEWS_API_KEY = "a5dd4e93c9b04cec9044ef561b3188cd"  
# NEWS_CATEGORY = "business"

# import re

# def fetch_news():
#     """
#     Fetches top headlines from NewsAPI in the specified category and returns a list of headlines.
#     """
#     url = f"https://newsapi.org/v2/top-headlines?country=us&category={NEWS_CATEGORY}&apiKey={NEWS_API_KEY}"
#     try:
#         response = requests.get(url)
#         response.raise_for_status()
#         data = response.json()
#         if data["status"] == "ok":
#             articles = data.get("articles", [])
#             headlines = [article["title"] for article in articles[:5]]  # top 5 headlines
#             return headlines
#         else:
#             return ["Failed to fetch news."]
#     except Exception as e:
#         print(f"Error fetching news: {e}")
#         return ["Error fetching news."]

# def processcommand(c):
#     command = c.strip().lower()
#     print(f"Processing command: '{command}'")
#     if "google" in command:
#         webbrowser.open("https://www.google.com")
#     elif "youtube" in command:
#         webbrowser.open("https://www.youtube.com")
#     elif "stackoverflow" in command:
#         webbrowser.open("https://stackoverflow.com")
#     elif "github" in command:
#         webbrowser.open("https://github.com")
#     elif c.lower().startswith("play"):
#        song=c.lower().split(" ")[1]
#        link=music.play(song)
#        webbrowser.open(link)
#     elif "news" in command:
#         speak("Fetching the latest news headlines.")
#         headlines = fetch_news()
#         for headline in headlines:
#             speak(headline)
#     elif "jarvis" in command:
#         speak("Hello sir, how can I help you?")
#     elif "exit" in command or "stop" in command:
#         speak("Goodbye!")
#         sys.exit(0)
#     else:
#         # Check for ask openai or ask open ai command using regex
#         match = re.match(r"ask open\s*ai\s*(.*)", command)
#         if match:
#             user_query = match.group(1).strip()
#             print(f"Extracted user query: '{user_query}'")  # Debug print
#             if not user_query:
#                 speak("Please provide a question after 'ask open ai'")
#             else:
#                 try:
#                     speak("Let me think...")
#                     messages = [
#                         {"role": "system", "content": "You are a helpful assistant."},
#                         {"role": "user", "content": user_query}
#                     ]
#                     response = openai_client.create_chat_completion("gpt-4o-mini", messages)
#                     if response:
#                         answer = response.choices[0].message.content
#                         print(f"OpenAI response: {answer}")
#                         speak(answer)
#                     else:
#                         print("No response from OpenAI API")
#                         speak("Sorry, I could not get a response from OpenAI.")
#                 except Exception as e:
#                     print(f"Exception during OpenAI call: {e}")
#                     speak("An error occurred while communicating with OpenAI.")
#         else:
#             print(f"Command not recognized: '{command}'")
#             speak("Command not recognized")

# def speak(text):
#     engine.say(text)
#     try:
#         engine.runAndWait()
#     except RuntimeError as e:
#         print(f"RuntimeError in speak(): {e}")

# try:
#     microphone = sr.Microphone()
# except OSError as e:
#     print(f"Microphone initialization error: {e}")
#     speak("Microphone initialization failed. Please check your microphone.")
#     sys.exit(1)

# if __name__ == "__main__":
#     speak("initializing jarvis....")
#     recognizer = sr.Recognizer()
#     try:
#         while True:
#             with microphone as source:
#                 print("listening...")
#                 try:
#                     audio = recognizer.listen(source, timeout=5, phrase_time_limit=5)
#                 except sr.WaitTimeoutError:
#                     print("Listening timed out while waiting for phrase to start")
#                     continue
#                 except Exception as e:
#                     print(f"Error during listening: {e}")
#                     speak("An error occurred while listening.")
#                     continue
#             try:
#                 query = recognizer.recognize_google(audio)
#                 print(f"Recognized: {query}")
#                 speak("yes sir")
#                 processcommand(query)
#             except sr.UnknownValueError:
#                 print("Sorry, I didn't catch that")
#                 speak("Sorry, I didn't catch that")
#             except sr.RequestError as e:
#                 print(f"Recognition error; {e}")
#                 speak("Recognition error occurred")
#             except (socket.timeout, ConnectionResetError, ConnectionRefusedError) as e:
#                 print(f"Network error during recognition: {e}")
#                 speak("Network error occurred during recognition")
#             except Exception as e:
#                 print(f"Unexpected error: {e}")
#                 speak("An unexpected error occurred.")
#             time.sleep(0.5)
#     except KeyboardInterrupt:
#         print("Exiting program on user interrupt")
#         # Avoid calling speak here to prevent RuntimeError
#         sys.exit(0)

# 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